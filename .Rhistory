print(coef_vec[names(top_coef)])
# Optional barplot
barplot(sort(coef_vec[names(top_coef)]), horiz = TRUE, las = 1,
main = paste("Top PCR coefficients (k_best =", k_best, ")"))
library(caret)
library(FactoMineR)
library(pls)
library(factoextra)  # install.packages("factoextra") if needed
set.seed(123)
train_index <- createDataPartition(y, p = 0.8, list = FALSE)
test_index  <- setdiff(seq_len(nrow(X)), train_index)
# Keep only numeric predictors for PCA/PCR
num_cols <- sapply(X, is.numeric)
X_num <- X[, num_cols, drop = FALSE]
# Split
X_train_num <- X_num[train_index, , drop = FALSE]
X_test_num  <- X_num[test_index,  , drop = FALSE]
y_train <- y[train_index]
y_test  <- y[test_index]
# ----------------------------
# Metrics helper
# ----------------------------
metrics <- function(y_true, y_pred) {
MAE  <- mean(abs(y_true - y_pred))
RMSE <- sqrt(mean((y_true - y_pred)^2))
R2   <- 1 - sum((y_true - y_pred)^2) / sum((y_true - mean(y_true))^2)
c(MAE = MAE, RMSE = RMSE, R2 = R2)
}
# ============================================================
# 1) PCR with CV-selected k (best-practice for choosing k)
# ============================================================
set.seed(123)
pcr_cv <- pcr(
y_train ~ .,
data = data.frame(y_train = y_train, X_train_num),
scale = TRUE,          # standardize before PCA/PCR
validation = "CV"
)
rmse_cv <- RMSEP(pcr_cv)$val[1, 1, -1]   # CV RMSE for 1..ncomp
k_best <- which.min(rmse_cv)
pred_test <- as.vector(predict(pcr_cv, newdata = data.frame(X_test_num), ncomp = k_best))
cat("\n--- PCR (pls::pcr) with CV-selected k ---\n")
cat("k_best =", k_best, "out of", ncol(X_train_num), "max PCs\n")
print(metrics(y_test, pred_test))
# ============================================================
# 2) PCA visuals (FactoMineR) using TRAIN fit, TEST as supplementary
#    -> this gives you course-style plots
# ============================================================
X_all <- rbind(X_train_num, X_test_num)
ind_sup <- (nrow(X_train_num) + 1):nrow(X_all)
res_pca <- PCA(
X_all,
ind.sup = ind_sup,
scale.unit = TRUE,
ncp = min(ncol(X_train_num), nrow(X_train_num) - 1),
graph = FALSE
)
# ============================================================
# 2bis) Normal lm() on the PCs (stable linear model)
# ============================================================
k_lm <- k_best   # use the CV-selected number of PCs from PCR
# (or set k_lm <- 10 if you want fixed k for presentation)
Z_train_lm <- res_pca$ind$coord[, 1:k_lm, drop = FALSE]
Z_test_lm  <- res_pca$ind.sup$coord[, 1:k_lm, drop = FALSE]
lm_pc <- lm(y_train ~ ., data = as.data.frame(Z_train_lm))
summary(lm_pc)  # <-- this is a normal lm summary (TRAIN R^2 etc.)
pred_lm <- predict(lm_pc, newdata = as.data.frame(Z_test_lm))
cat("\n--- lm() on PCs ---\n")
cat("k_lm =", k_lm, "\n")
print(metrics(y_test, pred_lm))  # <-- TEST MAE/RMSE/R2 (the ones you care about)
# ---- Plots like in courses ----
# Scree plot (variance explained by PCs)
fviz_eig(res_pca, addlabels = TRUE)
# Correlation circle / variable map (what defines PC1/PC2)
fviz_pca_var(res_pca, col.var = "cos2", repel = TRUE)
# Individuals map (countries); supplementary test points are shown too
fviz_pca_ind(res_pca, repel = TRUE)
# Biplot (variables + individuals together)
fviz_pca_biplot(res_pca, repel = TRUE)
# Top contributing variables to PC1 and PC2 (very slide-friendly)
fviz_contrib(res_pca, choice = "var", axes = 1, top = 10)
fviz_contrib(res_pca, choice = "var", axes = 2, top = 10)
# Also print top contributors numerically (quick to paste into slides)
cat("\n--- Top contributors to PC1 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,1], decreasing = TRUE), 10))
cat("\n--- Top contributors to PC2 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,2], decreasing = TRUE), 10))
# ============================================================
# 3) “What variables did the model decide on?”
#    PCR doesn't select variables; it selects PCs.
#    But we can rank original variables by the final PCR coefficients.
# ============================================================
coef_arr <- coef(pcr_cv, ncomp = k_best, intercept = TRUE)  # matrix/array
coef_vec <- as.vector(coef_arr)
names(coef_vec) <- rownames(coef_arr)
# Drop intercept if present
coef_vec <- coef_vec[names(coef_vec) != "(Intercept)"]
# Rank by absolute size (importance-ish)
top_coef <- sort(abs(coef_vec), decreasing = TRUE)[1:15]
cat("\n--- Top 15 original variables by |PCR coefficient| (k_best) ---\n")
print(coef_vec[names(top_coef)])
# Optional barplot
barplot(sort(coef_vec[names(top_coef)]), horiz = TRUE, las = 1,
main = paste("Top PCR coefficients (k_best =", k_best, ")"))
summary(lm_pc)
summary(lm_pc)
alias(lm_pc)
summary(lm_pc)
R2_test <- 1 - sum((y_test - pred_lm)^2) / sum((y_test - mean(y_test))^2)
R2_test
library(readxl)
library(dplyr)
library(stringr)
library(ggplot2)
library(lubridate)
library(fastDummies)
library(caret)
library(tidyr)
load_mydf <- function() {
df <- read_excel("data/toutlespays.xlsx")
names(df) <- names(df) |>
str_replace("\r\n", " ") |>
str_replace("\n", " ") |>
str_squish()
names(df)[str_detect(names(df), "Overshoot Day")] <- "Overshoot Day"
rename_pattern <- function(pattern, newname) {
idx <- str_detect(names(df), pattern)
names(df)[idx] <<- newname
}
rename_pattern("^Cropland Footprint.*10$",      "Cropland_Footprint_Production")
rename_pattern("^Grazing Footprint.*11$",       "Grazing_Footprint_Production")
rename_pattern("^Forest Product Footprint.*12$","Forest_Footprint_Production")
rename_pattern("^Fish Footprint.*13$",          "Fish_Footprint_Production")
rename_pattern("^Built up land.*14$",           "BuiltUp_Footprint_Production")
rename_pattern("^Carbon Footprint.*15$",        "Carbon_Footprint_Production")
rename_pattern("^Cropland Footprint.*17$",      "Cropland_Footprint_Consumption")
rename_pattern("^Grazing Footprint.*18$",       "Grazing_Footprint_Consumption")
rename_pattern("^Forest Product Footprint.*19$","Forest_Footprint_Consumption")
rename_pattern("^Fish Footprint.*20$",          "Fish_Footprint_Consumption")
rename_pattern("^Built up land.*21$",           "BuiltUp_Footprint_Consumption")
rename_pattern("^Carbon Footprint.*22$",        "Carbon_Footprint_Consumption")
rename_pattern("^Built up land.*28$",           "BuiltUp_Biocapacity")
names(df)[names(df) == "Total_Footprint_Production"] <- "Total_Footprint_Production"
names(df)[names(df) == "Total_Footprint_Consumption"] <- "Total_Footprint_Consumption"
names(df)[names(df) == "Total_Biocapacity"] <- "Total_Biocapacity"
force_text <- c("Country", "Region", "Income Group", "Overshoot Day", "Quality Score")
clean_numeric <- function(x) {
if (!is.character(x)) return(x)
x <- str_replace_all(x, "[\u202f,$% ]", "")
suppressWarnings(as.numeric(x))
}
for (col in names(df)) {
if (!(col %in% force_text)) {
df[[col]] <- clean_numeric(df[[col]])
}
}
return(df)
}
df <- load_mydf()
names(df)
overshoot_to_doy <- function(x) {
dt <- suppressWarnings(as.Date(x, format = "%B %d, %Y"))
ifelse(is.na(dt), NA, yday(dt))
}
df$Overshoot_Day_DOY <- overshoot_to_doy(df$`Overshoot Day`)
df_supervised <- df %>% filter(!is.na(Overshoot_Day_DOY)) %>% drop_na()
df_supervised_encoded <- fastDummies::dummy_cols(
df_supervised,
select_columns = "Income Group",
remove_first_dummy = TRUE,
remove_selected_columns = TRUE
)
drop_cols <- c("Country", "Region", "Overshoot Day", "Quality Score")
X <- df_supervised_encoded %>% select(-all_of(drop_cols), -Overshoot_Day_DOY)
y <- df_supervised_encoded$Overshoot_Day_DOY
library(caret)
library(FactoMineR)
library(pls)
library(factoextra)
set.seed(123)
train_index <- createDataPartition(y, p = 0.8, list = FALSE)
test_index  <- setdiff(seq_len(nrow(X)), train_index)
num_cols <- sapply(X, is.numeric)
X_num <- X[, num_cols, drop = FALSE]
X_train_num <- X_num[train_index, , drop = FALSE]
X_test_num  <- X_num[test_index,  , drop = FALSE]
y_train <- y[train_index]
y_test  <- y[test_index]
metrics <- function(y_true, y_pred) {
MAE  <- mean(abs(y_true - y_pred))
RMSE <- sqrt(mean((y_true - y_pred)^2))
R2   <- 1 - sum((y_true - y_pred)^2) / sum((y_true - mean(y_true))^2)
c(MAE = MAE, RMSE = RMSE, R2 = R2)
}
set.seed(123)
pcr_cv <- pcr(
y_train ~ .,
data = data.frame(y_train = y_train, X_train_num),
scale = TRUE,
validation = "CV"
)
rmse_cv <- RMSEP(pcr_cv)$val[1, 1, -1]
k_best <- which.min(rmse_cv)
pred_test <- as.vector(predict(pcr_cv, newdata = data.frame(X_test_num), ncomp = k_best))
cat("\n--- PCR (pls::pcr) with CV-selected k ---\n")
cat("k_best =", k_best, "out of", ncol(X_train_num), "max PCs\n")
print(metrics(y_test, pred_test))
X_all <- rbind(X_train_num, X_test_num)
ind_sup <- (nrow(X_train_num) + 1):nrow(X_all)
res_pca <- PCA(
X_all,
ind.sup = ind_sup,
scale.unit = TRUE,
ncp = min(ncol(X_train_num), nrow(X_train_num) - 1),
graph = FALSE
)
k_lm <- k_best
Z_train_lm <- res_pca$ind$coord[, 1:k_lm, drop = FALSE]
Z_test_lm  <- res_pca$ind.sup$coord[, 1:k_lm, drop = FALSE]
lm_pc <- lm(y_train ~ ., data = as.data.frame(Z_train_lm))
summary(lm_pc)
pred_lm <- predict(lm_pc, newdata = as.data.frame(Z_test_lm))
cat("\n--- lm() on PCs ---\n")
cat("k_lm =", k_lm, "\n")
print(metrics(y_test, pred_lm))
fviz_eig(res_pca, addlabels = TRUE)
fviz_pca_var(res_pca, col.var = "cos2", repel = TRUE)
fviz_pca_ind(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE)
fviz_contrib(res_pca, choice = "var", axes = 1, top = 10)
fviz_contrib(res_pca, choice = "var", axes = 2, top = 10)
cat("\n--- Top contributors to PC1 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,1], decreasing = TRUE), 10))
cat("\n--- Top contributors to PC2 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,2], decreasing = TRUE), 10))
coef_arr <- coef(pcr_cv, ncomp = k_best, intercept = TRUE)  # matrix/array
coef_vec <- as.vector(coef_arr)
names(coef_vec) <- rownames(coef_arr)
-coef_vec <- coef_vec[names(coef_vec) != "(Intercept)"]
step(modele1, method="both")
modele1 <- lm(y_train ~ SDGi + `Life Expectancy`  + HDI+ `Per Capita GDP` + `Population (millions)` + Cropland_Footprint_Production +
Grazing_Footprint_Production +
Forest_Footprint_Production +
Fish_Footprint_Production +
BuiltUp_Footprint_Production+ Cropland_Footprint_Consumption +
Grazing_Footprint_Consumption +
Forest_Footprint_Consumption +
Fish_Footprint_Consumption  +
`Grazing land` +
`Forest land` +
`Fishing ground` +  `Ecological (Deficit) or Reserve`  +
`Number of Countries required` +
`Income Group_LM` +
`Income Group_UM`, data = X_train )
summary(lm_pc)
R2_test <- 1 - sum((y_test - pred_lm)^2) / sum((y_test - mean(y_test))^2)
R2_test
set.seed(123)
train_index <- createDataPartition(y, p = 0.8, list = FALSE)
X_train <- X[train_index, , drop = FALSE]
X_test  <- X[-train_index, , drop = FALSE]
y_train <- y[train_index]
y_test  <- y[-train_index]
modele1 <- lm(y_train ~ SDGi + `Life Expectancy`  + HDI+ `Per Capita GDP` + `Population (millions)` + Cropland_Footprint_Production +
Grazing_Footprint_Production +
Forest_Footprint_Production +
Fish_Footprint_Production +
BuiltUp_Footprint_Production+ Cropland_Footprint_Consumption +
Grazing_Footprint_Consumption +
Forest_Footprint_Consumption +
Fish_Footprint_Consumption  +
`Grazing land` +
`Forest land` +
`Fishing ground` +  `Ecological (Deficit) or Reserve`  +
`Number of Countries required` +
`Income Group_LM` +
`Income Group_UM`, data = X_train )
summary(modele1)
step(modele1, method="both")
modele1step <- lm(formula = y_train ~ SDGi + `Life Expectancy` + HDI + `Per Capita GDP` +
`Population (millions)` + Cropland_Footprint_Production +
Fish_Footprint_Production + BuiltUp_Footprint_Production +
Cropland_Footprint_Consumption + `Grazing land` + `Forest land` +
`Fishing ground` + `Ecological (Deficit) or Reserve` + `Income Group_LM` +
`Income Group_UM`, data = X_train)
summary(modele1step)
modele1step <- lm(formula = y_train ~ SDGi + `Life Expectancy` + HDI + `Per Capita GDP` +
`Population (millions)` + Cropland_Footprint_Production +
Fish_Footprint_Production + BuiltUp_Footprint_Production +
Cropland_Footprint_Consumption + `Grazing land` + `Forest land` +
`Fishing ground` + `Ecological (Deficit) or Reserve` + `Income Group_LM` +
`Income Group_UM`, data = X_train)
summary(modele1step)
AIC(modele1step)
library(readxl)
library(dplyr)
library(stringr)
library(ggplot2)
library(lubridate)
library(fastDummies)
library(caret)
library(tidyr)
load_mydf <- function() {
df <- read_excel("data/toutlespays.xlsx")
names(df) <- names(df) |>
str_replace("\r\n", " ") |>
str_replace("\n", " ") |>
str_squish()
names(df)[str_detect(names(df), "Overshoot Day")] <- "Overshoot Day"
rename_pattern <- function(pattern, newname) {
idx <- str_detect(names(df), pattern)
names(df)[idx] <<- newname
}
rename_pattern("^Cropland Footprint.*10$",      "Cropland_Footprint_Production")
rename_pattern("^Grazing Footprint.*11$",       "Grazing_Footprint_Production")
rename_pattern("^Forest Product Footprint.*12$","Forest_Footprint_Production")
rename_pattern("^Fish Footprint.*13$",          "Fish_Footprint_Production")
rename_pattern("^Built up land.*14$",           "BuiltUp_Footprint_Production")
rename_pattern("^Carbon Footprint.*15$",        "Carbon_Footprint_Production")
rename_pattern("^Cropland Footprint.*17$",      "Cropland_Footprint_Consumption")
rename_pattern("^Grazing Footprint.*18$",       "Grazing_Footprint_Consumption")
rename_pattern("^Forest Product Footprint.*19$","Forest_Footprint_Consumption")
rename_pattern("^Fish Footprint.*20$",          "Fish_Footprint_Consumption")
rename_pattern("^Built up land.*21$",           "BuiltUp_Footprint_Consumption")
rename_pattern("^Carbon Footprint.*22$",        "Carbon_Footprint_Consumption")
rename_pattern("^Built up land.*28$",           "BuiltUp_Biocapacity")
names(df)[names(df) == "Total_Footprint_Production"] <- "Total_Footprint_Production"
names(df)[names(df) == "Total_Footprint_Consumption"] <- "Total_Footprint_Consumption"
names(df)[names(df) == "Total_Biocapacity"] <- "Total_Biocapacity"
force_text <- c("Country", "Region", "Income Group", "Overshoot Day", "Quality Score")
clean_numeric <- function(x) {
if (!is.character(x)) return(x)
x <- str_replace_all(x, "[\u202f,$% ]", "")
suppressWarnings(as.numeric(x))
}
for (col in names(df)) {
if (!(col %in% force_text)) {
df[[col]] <- clean_numeric(df[[col]])
}
}
return(df)
}
df <- load_mydf()
names(df)
overshoot_to_doy <- function(x) {
dt <- suppressWarnings(as.Date(x, format = "%B %d, %Y"))
ifelse(is.na(dt), NA, yday(dt))
}
df$Overshoot_Day_DOY <- overshoot_to_doy(df$`Overshoot Day`)
df_supervised <- df %>% filter(!is.na(Overshoot_Day_DOY)) %>% drop_na()
df_supervised_encoded <- fastDummies::dummy_cols(
df_supervised,
select_columns = "Income Group",
remove_first_dummy = TRUE,
remove_selected_columns = TRUE
)
drop_cols <- c("Country", "Region", "Overshoot Day", "Quality Score")
X <- df_supervised_encoded %>% select(-all_of(drop_cols), -Overshoot_Day_DOY)
y <- df_supervised_encoded$Overshoot_Day_DOY
library(caret)
library(FactoMineR)
library(pls)
library(factoextra)
set.seed(123)
train_index <- createDataPartition(y, p = 0.8, list = FALSE)
test_index  <- setdiff(seq_len(nrow(X)), train_index)
num_cols <- sapply(X, is.numeric)
X_num <- X[, num_cols, drop = FALSE]
X_train_num <- X_num[train_index, , drop = FALSE]
X_test_num  <- X_num[test_index,  , drop = FALSE]
y_train <- y[train_index]
y_test  <- y[test_index]
metrics <- function(y_true, y_pred) {
MAE  <- mean(abs(y_true - y_pred))
RMSE <- sqrt(mean((y_true - y_pred)^2))
R2   <- 1 - sum((y_true - y_pred)^2) / sum((y_true - mean(y_true))^2)
c(MAE = MAE, RMSE = RMSE, R2 = R2)
}
set.seed(123)
pcr_cv <- pcr(
y_train ~ .,
data = data.frame(y_train = y_train, X_train_num),
scale = TRUE,
validation = "CV"
)
rmse_cv <- RMSEP(pcr_cv)$val[1, 1, -1]
k_best <- which.min(rmse_cv)
pred_test <- as.vector(predict(pcr_cv, newdata = data.frame(X_test_num), ncomp = k_best))
cat("\n--- PCR (pls::pcr) with CV-selected k ---\n")
cat("k_best =", k_best, "out of", ncol(X_train_num), "max PCs\n")
print(metrics(y_test, pred_test))
X_all <- rbind(X_train_num, X_test_num)
ind_sup <- (nrow(X_train_num) + 1):nrow(X_all)
res_pca <- PCA(
X_all,
ind.sup = ind_sup,
scale.unit = TRUE,
ncp = min(ncol(X_train_num), nrow(X_train_num) - 1),
graph = FALSE
)
k_lm <- k_best
Z_train_lm <- res_pca$ind$coord[, 1:k_lm, drop = FALSE]
Z_test_lm  <- res_pca$ind.sup$coord[, 1:k_lm, drop = FALSE]
lm_pc <- lm(y_train ~ ., data = as.data.frame(Z_train_lm))
summary(lm_pc)
pred_lm <- predict(lm_pc, newdata = as.data.frame(Z_test_lm))
cat("\n--- lm() on PCs ---\n")
cat("k_lm =", k_lm, "\n")
print(metrics(y_test, pred_lm))
fviz_eig(res_pca, addlabels = TRUE)
fviz_pca_var(res_pca, col.var = "cos2", repel = TRUE)
fviz_pca_ind(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE)
fviz_contrib(res_pca, choice = "var", axes = 1, top = 10)
fviz_contrib(res_pca, choice = "var", axes = 2, top = 10)
cat("\n--- Top contributors to PC1 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,1], decreasing = TRUE), 10))
cat("\n--- Top contributors to PC2 (FactoMineR) ---\n")
print(head(sort(res_pca$var$contrib[,2], decreasing = TRUE), 10))
coef_arr <- coef(pcr_cv, ncomp = k_best, intercept = TRUE)  # matrix/array
coef_vec <- as.vector(coef_arr)
names(coef_vec) <- rownames(coef_arr)
-coef_vec <- coef_vec[names(coef_vec) != "(Intercept)"]
summary(lm_pc)
R2_test <- 1 - sum((y_test - pred_lm)^2) / sum((y_test - mean(y_test))^2)
R2_test
set.seed(123)
train_index <- createDataPartition(y, p = 0.8, list = FALSE)
X_train <- X[train_index, , drop = FALSE]
X_test  <- X[-train_index, , drop = FALSE]
y_train <- y[train_index]
y_test  <- y[-train_index]
full_model <- lm(y_train ~ ., data = X_train)
summary(full_model)
modele0 <- lm(y_train ~ SDGi + `Life Expectancy`  + HDI+ `Per Capita GDP` + `Population (millions)` + Cropland_Footprint_Production +
Grazing_Footprint_Production +
Forest_Footprint_Production +
Fish_Footprint_Production +
BuiltUp_Footprint_Production+ Cropland_Footprint_Consumption +
Grazing_Footprint_Consumption +
Forest_Footprint_Consumption +
Fish_Footprint_Consumption +
BuiltUp_Footprint_Consumption + Cropland  +
`Grazing land` +
`Forest land` +
`Fishing ground` +
BuiltUp_Biocapacity +  `Ecological (Deficit) or Reserve`
+ `Number of Earths required` +
`Number of Countries required`+
`Income Group_LM` +
`Income Group_UM`, data = X_train )
summary(modele0)
alias(full_model)
alias(modele0)
modele1 <- lm(y_train ~ SDGi + `Life Expectancy`  + HDI+ `Per Capita GDP` + `Population (millions)` + Cropland_Footprint_Production +
Grazing_Footprint_Production +
Forest_Footprint_Production +
Fish_Footprint_Production +
BuiltUp_Footprint_Production+ Cropland_Footprint_Consumption +
Grazing_Footprint_Consumption +
Forest_Footprint_Consumption +
Fish_Footprint_Consumption  +
`Grazing land` +
`Forest land` +
`Fishing ground` +  `Ecological (Deficit) or Reserve`  +
`Number of Countries required` +
`Income Group_LM` +
`Income Group_UM`, data = X_train )
summary(modele1)
step(modele1, method="both")
modele1step <- lm(formula = y_train ~ SDGi + `Life Expectancy` + HDI + `Per Capita GDP` +
`Population (millions)` + Cropland_Footprint_Production +
Fish_Footprint_Production + BuiltUp_Footprint_Production +
Cropland_Footprint_Consumption + `Grazing land` + `Forest land` +
`Fishing ground` + `Ecological (Deficit) or Reserve` + `Income Group_LM` +
`Income Group_UM`, data = X_train)
summary(modele1step)
AIC(modele1step)
# suppose you have columns:
# bc = Total biocapacity
# ef = Total Ecological Footprint (Consumption) or the one used in your target
yhat_base_train <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
yhat_base_test  <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
# MAE in days
mae_base <- mean(abs(y_test - yhat_base_test))
# R^2 on test
r2_base <- 1 - sum((y_test - yhat_base_test)^2) / sum((y_test - mean(y_test))^2)
c(MAE = mae_base, R2 = r2_base)
# suppose you have columns:
# bc = Total biocapacity
# ef = Total Ecological Footprint (Consumption) or the one used in your target
yhat_base_train <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
yhat_base_test  <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
# MAE in days
mae_base <- mean(abs(y_test - yhat_base_test))
# R^2 on test
r2_base <- 1 - sum((y_test - yhat_base_test)^2) / sum((y_test - mean(y_test))^2)
c(MAE = mae_base, R2 = r2_base)
correlation(modele1step)
# suppose you have columns:
# bc = Total biocapacity
# ef = Total Ecological Footprint (Consumption) or the one used in your target
yhat_base_train <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
yhat_base_test  <- 365 * (X_train$`Total biocapacity` / X_train$`Total Ecological Footprint (Consumption)`)
# MAE in days
mae_base <- mean(abs(y_test - yhat_base_test))
# R^2 on test
r2_base <- 1 - sum((y_test - yhat_base_test)^2) / sum((y_test - mean(y_test))^2)
c(MAE = mae_base, R2 = r2_base)
cormat <- round(cor(modele1step),2)
summary(modèle1step)
summary(modele1step)
